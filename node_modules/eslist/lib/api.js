"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var manufacturer_collection_1 = require("./utils/manufacturer_collection");
function api(store) {
    function set(key, data, pending, helper) {
        if (pending === void 0) { pending = false; }
        if (store.has(key.toString()))
            return false;
        var collection = manufacturer_collection_1.init_collection(data, helper);
        if (pending) {
            collection.pending = 'setted';
        }
        else {
            collection.state = 'setted';
        }
        store.set(key.toString(), __assign(__assign({}, collection), { key: key.toString() }));
        return true;
    }
    function add(data, pending, helper) {
        if (pending === void 0) { pending = false; }
        var collection = manufacturer_collection_1.init_collection(data, helper);
        if (pending) {
            collection.pending = 'added';
            collection.state = 'never';
        }
        else {
            collection.state = 'added';
            collection.backup = null;
        }
        store.set(collection.key, collection);
        return __assign(__assign({}, data), { key: collection.key });
    }
    function get(key, force) {
        if (force === void 0) { force = false; }
        var collection = store.get(key.toString());
        if (force) {
            if (collection) {
                return __assign(__assign({}, collection.data), { key: collection.key });
            }
        }
        else if (collection && !collection.hide) {
            return __assign(__assign({}, collection.data), { key: collection.key });
        }
        return null;
    }
    function update(key, data, pending) {
        if (pending === void 0) { pending = false; }
        var collection = store.get(key.toString());
        if (collection && !collection.hide) {
            if (pending) {
                collection.backup = __assign({}, collection.data);
                collection.pending = 'updated';
            }
            else {
                collection.pending = null;
                collection.backup = null;
                collection.state = 'updated';
            }
            collection.data = __assign(__assign({}, collection.data), data);
            return true;
        }
        return false;
    }
    function del(key, pending) {
        if (pending === void 0) { pending = false; }
        var collection = store.get(key.toString());
        if (collection && !collection.hide) {
            if (pending) {
                collection.pending = 'deleted';
                return true;
            }
            else {
                collection.pending = null;
                if (collection.system) {
                    collection.state = 'deleted';
                    return true;
                }
                else {
                    return store.delete(key.toString());
                }
            }
        }
        return false;
    }
    var datalist = function () {
        var list = [];
        store.forEach(function (collection) {
            if (!(collection.state === 'deleted' ||
                collection.pending === 'deleted' ||
                collection.hide))
                list.push(__assign(__assign({}, collection.data), { key: collection.key }));
        });
        return list;
    };
    function each(callbackfn) {
        var list = [];
        var count = -1;
        store.forEach(function (collection) {
            if (!(collection.state === 'deleted' ||
                collection.pending === 'deleted' ||
                collection.hide)) {
                count++;
                list.push(callbackfn(__assign(__assign({}, collection.data), { key: collection.key }), collection.helper || null, count));
            }
        });
        return list;
    }
    return {
        set: set,
        add: add,
        get: get,
        update: update,
        del: del,
        datalist: datalist,
        each: each
    };
}
exports.default = api;
