import { State, Custom } from './utils/manufacturer_collection';
export interface Eslist<T, K = undefined> {
    (list?: Array<T>, custom?: (item: T) => Custom<T, K>): Array<T & {
        key: string;
    }>;
    add: (data: T, pending?: boolean, helper?: K | undefined) => T & {
        key: string;
    };
    set: (key: string | number, data: T, pending?: boolean, helper?: K | undefined) => boolean;
    update: (key: string | number, data: Partial<T>, pending?: boolean) => boolean;
    delete: (key: string | number, pending?: boolean) => boolean;
    get: (key: string | number, force?: boolean) => (T & {
        key: string;
    }) | null;
    each: <L>(callbackfn: (data: T & {
        key: string;
    }, helper: K | null, index: number) => L) => Array<L>;
    init: (list?: T[], custom?: (item: T) => Custom<T, K>) => void;
    mapping: <L>(callbackfn: (data: T, state: State) => L) => L[];
    confirm: (key: string | number) => boolean;
    cancel: (key: string | number) => boolean;
    helper: (key: string | number, content_helper?: K | undefined) => K | null;
    frozen: (key: string | number) => (T & {
        key: string;
    }) | null;
}
declare function eslist<T, K = undefined>(collections?: Array<T>, custom?: (item: T) => Custom<T, K>): Eslist<T, K>;
export default eslist;
